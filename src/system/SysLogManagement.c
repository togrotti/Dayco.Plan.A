/****************************************************************************/
/* Project: Ax-Zynq Control Board                                           */
/*                                                                          */
/* Copyright Â© 2021, Ningbo Physis Technology Co.,Ltd. All Rights Reserved. */
/*                                                                          */
/* File        : SysLogManagement.c                                         */
/* Author      : Hu Xiaokai                                                 */
/*                                                                          */
/* Description : System Alarms and Time Logging Management Facility         */
/*                                                                          */
/****************************************************************************/
// Compiler Option
#ifndef _INFINEON_
#pragma GCC optimize (2)
#endif

#include "common\CommonDefines.h"
#include "system\SysLogManagement.h"
#include "system\SysAppGlobals.h"
#include "system\SystemStatus.h"
#include "system\SystemAlarms.h"
#include "system\SysAppDataCodes.h"
#include "common\CommonUtility.h"
//#include "FatalErrorCodes.h"
#include "common\FlashManager.h"
#include "common\ProgramFlashHandler.h"
#include "system\SysLogData.h"
#include "plc\PlcRetainMgr.h"
#include "system\Os.h"
#include "common\TaskScheduler.h"
#include "common\BlockStorage.h"
#include "core\SystemReset.h"
#include "common\ParamStorageManagement.h"
#include "common\SecurityCrypto.h"
#include "system\GlobalResetCodes.h"

#include <string.h>

#ifdef _INFINEON_
#include <intrins.h>

//***************************************************************************
// Some data is required to pass-through bootblock code and reset CINIT
// in order to save time across a reset generated by external button
// and/or software reset

#pragma renameclass(FDATA=SYSLOGMG)
#endif
//***************************************************************************
// Defines

#define STORAGEGRANULARITY          (PROGRAMFLASH_PAGE_SIZE)
#define ALARMQUEUESIZE              8
#define CLOCKQUEUESIZE              2

#define POWERFAILSAVEELEMENTS       2

    // for security against manual reset, the only case that cannot be
    // safely handled, clock is saved every 4h; theoretically, respecting
    // datasheet, that guaranteed 20 year retention with 1000 program/erase
    // cycle, and reserved memory, 32*3 128bytes block, it could be saved
    // every 1h49m30s
#define SAVECLOCKEVERYNSECONDS      (4l*3600l)

    // just in case all data is zero, this let's get a not zero crc
#define CRCINITIALSEED              0xBEEF

    // options passed across postalarm and slowtask via DATACODE_SYSLOG_INVALID
#define POSTOPTIONS_NONE            0x0000
#define POSTOPTIONS_NOFLASHSTORE    0x0001

//***************************************************************************
// Data structure

typedef struct
{
    HPVOID hpvStart;
    ULONG ulSize;
} BLOCKDEFS;

typedef struct
{
    ULONG ulAbsTime;
    HPVOID hpvAddress;
    UWORD uwSize;
} ENTRYLIST;

typedef struct
{
    HPVOID hpvSrc;
    HPVOID hpvDst;
    UWORD  uwCrc;
} POWERFAILSAVE;

//***************************************************************************
// Globals

//OS_CREATEPUREQUEUE(SysLogMgm_AlrmAvailableElements);
//OS_CREATEPUREQUEUE(SysLogMgm_AlarmQueue,ALARMQUEUESIZE,STORAGEGRANULARITY);

volatile OS_QUEUE SysLogMgm_AlarmQueue;

//***************************************************************************
// Linker defined publics

//extern UBYTE SYSLOG_CLK_BLK0_START;
//extern UBYTE SYSLOG_CLK_BLK0_SIZE;
//extern UBYTE SYSLOG_CLK_BLK1_START;
//extern UBYTE SYSLOG_CLK_BLK1_SIZE;
//extern UBYTE SYSLOG_CLK_BLK2_START;
//extern UBYTE SYSLOG_CLK_BLK2_SIZE;
//
//extern UBYTE SYSLOG_ALRM_BLK0_START;
//extern UBYTE SYSLOG_ALRM_BLK0_SIZE;
//extern UBYTE SYSLOG_ALRM_BLK1_START;
//extern UBYTE SYSLOG_ALRM_BLK1_SIZE;

//***************************************************************************
// Storage Blocks definition

static const BLOCKDEFS sClockBlockDefs[]=
{
    {(HPVOID)SYSLOG_CLK_BLK0_START, (ULONG)SYSLOG_CLK_BLK0_SIZE},
    {(HPVOID)SYSLOG_CLK_BLK1_START, (ULONG)SYSLOG_CLK_BLK1_SIZE},
    {(HPVOID)SYSLOG_CLK_BLK2_START, (ULONG)SYSLOG_CLK_BLK2_SIZE},
};

#define CLOCKBLOCKCOUNT             (sizeof(sClockBlockDefs)/sizeof(BLOCKDEFS))

static const BLOCKDEFS sAlarmsBlockDefs[]=
{
    {(HPVOID)SYSLOG_ALRM_BLK0_START, (ULONG)SYSLOG_ALRM_BLK0_SIZE},
    {(HPVOID)SYSLOG_ALRM_BLK1_START, (ULONG)SYSLOG_ALRM_BLK1_SIZE},
};

#define ALARMSBLOCKCOUNT            (sizeof(sAlarmsBlockDefs)/sizeof(BLOCKDEFS))

//***************************************************************************
// Module management

static BOOL bSysLogManagerEnabled=FALSE;
static BOOL bFlashStorageEnabled=FALSE;
static BOOL bRTPostAlarmValid0=FALSE;
static BOOL bRTPostAlarmValid1=FALSE;
static BOOL bSavedRTAlarm0=FALSE;
static BOOL bSavedRTAlarm1=FALSE;

//***************************************************************************
// Alarm status and queues

static UBYTE  psAlarmQueue[STORAGEGRANULARITY];
static ULONG  ulAlarmLastTime;
static HPVOID hpvAlarmNextFree;

static UBYTE  nubRTPostAlarmArea0[STORAGEGRANULARITY];
static UBYTE  nubRTPostAlarmArea1[STORAGEGRANULARITY];

static POWERFAILSAVE  sAlarmPowerFailSave[POWERFAILSAVEELEMENTS];
static POWERFAILSAVE  * psAlarmPowerFailSave;
static UWORD uwAlarmPowerFailSaveSel;

static ULONG  ulDisabledAlarmMask=0ul;

//***************************************************************************
// Clock status and queues; the parameters across NOINIT and INIT are not
// initialized, refer to renameclass directive at top of this module

//#pragma NOINIT
static UBYTE  psClockSave[POWERFAILSAVEELEMENTS][STORAGEGRANULARITY];
static UWORD  puwClockElemCrc[POWERFAILSAVEELEMENTS];
//#pragma INIT

static ULONG ulClockLastSavedTime;
static ULONG ulClockLastTime;
static HPVOID hpvClockNextFree;

static POWERFAILSAVE  sClockPowerFailSave[POWERFAILSAVEELEMENTS];
static POWERFAILSAVE  * psClockPowerFailSave;
static UWORD uwClockPowerFailSaveSel;

//***************************************************************************
// Local prototypes

static BOOL setnextfree(const BLOCKDEFS * blkdefs, const UWORD blkcount, void  * * blkpointer);
static void slowtask(void);
static HPUBYTE encodelogchunk(HPUBYTE,UWORD *);

//***************************************************************************
// Init

BOOL SysLogMgm_Init(void)
{
    UWORD ct,ctp,pagesize;
    UWORD cts;
    SWORD cti;
    HPVOID stor_addr;
    HPVOID found_addr;
    HPVOID sy_addr;
    HPVOID blk_addr;
    ULONG stor_size;
    SWORD blkcode;
    SYSLOGMGM_CLOCKLOG clklog;
    SYSLOGMGM_ALARMLOG alrmlog;
    ULONG abstime,alarmabstime;
    ENTRYLIST elst[SYSLOGDATA_ALARMS_MAX_ENTRIES];

        // check integrity
    assert(sizeof(SYSLOGMGM_DATATMPIDENT)<=sizeof(BLKSTOR_HEADER));

        // local init
    bFlashStorageEnabled=TRUE;
    psClockPowerFailSave=NULL;
    psAlarmPowerFailSave=NULL;
    uwAlarmPowerFailSaveSel=0;
    uwClockPowerFailSaveSel=0;

    	// alarm queue
    OS_CREATEPUREQUEUE(SysLogMgm_AlarmQueue,ALARMQUEUESIZE,STORAGEGRANULARITY);

//    for(ct=0;ct<ALARMQUEUESIZE;ct++)
//        Os_QueuePost(SysLogMgm_AlrmAvailableElements, (HPULONG)&ct);

    bRTPostAlarmValid0=FALSE;
    bRTPostAlarmValid1=FALSE;
    bSavedRTAlarm0=FALSE;
    bSavedRTAlarm1=FALSE;

        // init syslog data collection
    assert(SysLogData_Init());

        // scan all clock blocks to find the newest page
    hpvClockNextFree=NULL;
    abstime=0l;
    for(ct=0;ct<CLOCKBLOCKCOUNT;ct++)
    {
            // for each defined block
        pagesize=(UWORD)(sClockBlockDefs[ct].ulSize/STORAGEGRANULARITY);
            // scan each block page
        for(ctp=0;ctp<pagesize;ctp++)
        {
            found_addr=stor_addr=&(((HPUBYTE)sClockBlockDefs[ct].hpvStart)[STORAGEGRANULARITY*ctp]);
            stor_size=STORAGEGRANULARITY;

            blkcode=blkstor_enumvalid(&stor_addr, &stor_size, &blk_addr);

                // just first must be the right one
    		if(blkcode==DATACODE_SYSLOG_CLOCK)
    		{
			    if(blkstor_getdata(blk_addr,0,DATACODE_SYSLOG_CLOCK,&clklog,sizeof(clklog))>0)
                    if(clklog.ulAbsoluteTime>abstime)
                    {
                        abstime=clklog.ulAbsoluteTime;
                        hpvClockNextFree=found_addr;
                    }
            }
        }
    }

        // check clock save elements in order that if valid CRC then it could partecipate
        // with all other blocks to find the newer one
    sy_addr=NULL;
    for(ct=0;ct<POWERFAILSAVEELEMENTS;ct++)
    {
            // if element is valid
        if(puwClockElemCrc[ct]==crc16(CRCINITIALSEED, (HPVOID)psClockSave[ct], STORAGEGRANULARITY))
        {
                // encode it in order to use standard decode structure
            stor_addr=encodelogchunk((HPVOID)psClockSave[ct],NULL);
            stor_size=STORAGEGRANULARITY;
    
            blkcode=blkstor_enumvalid(&stor_addr, &stor_size, &blk_addr);

                // just first must be the right one
            if(blkcode==DATACODE_SYSLOG_CLOCK)
            {
                if(blkstor_getdata(blk_addr,0,DATACODE_SYSLOG_CLOCK,&clklog,sizeof(clklog))>0)
                    if(clklog.ulAbsoluteTime>abstime)
                    {
                        abstime=clklog.ulAbsoluteTime;
                        sy_addr=psClockSave[ct];
                    }
            }
        }
    }
    
        // if sy_addr not NULL then there's more recent data in RAM than in flash
    if(sy_addr)
    {
            // encode it
        sy_addr=encodelogchunk(sy_addr,NULL);

            // then restore data collections
        assert(SysLogData_RestoreClockLogData(sy_addr, STORAGEGRANULARITY));
        assert(PlcRetMgr_RestoreRetainData(sy_addr, STORAGEGRANULARITY));
    }

        // if found in flash
    if(hpvClockNextFree)
    {
            // but not in ram
        if(!sy_addr)
        {
                // restore data collections from latest clock log entry
            assert(SysLogData_RestoreClockLogData(hpvClockNextFree, STORAGEGRANULARITY));
            assert(PlcRetMgr_RestoreRetainData(hpvClockNextFree, STORAGEGRANULARITY));
        }
    }
        // otherwise set next free for the first time
    else
        hpvClockNextFree=sClockBlockDefs[0].hpvStart;

        // set the newest page
    if(!setnextfree(sClockBlockDefs, CLOCKBLOCKCOUNT, &hpvClockNextFree))
        bFlashStorageEnabled=FALSE;

        // erase local table for found alarms in the alarms storage blocks,
        // it will contain a cronologically sorted list of alarms, up
        // to SYSLOGDATA_ALARMS_MAX_ENTRIES
    for(ct=0;ct<SYSLOGDATA_ALARMS_MAX_ENTRIES;ct++)
    {
        elst[ct].ulAbsTime=0l; 
        elst[ct].hpvAddress=NULL;
        elst[ct].uwSize=0;
    }

        // now scan all alarm blocks to find the newest page and to
        // fill-up alarm history table
    hpvAlarmNextFree=NULL;
    alarmabstime=0l;
    for(ct=0;ct<ALARMSBLOCKCOUNT;ct++)
    {
            // for each defined block
        pagesize=(UWORD)(sAlarmsBlockDefs[ct].ulSize/STORAGEGRANULARITY);
            // scan each block page
        for(ctp=0;ctp<pagesize;ctp++)
        {
            found_addr=stor_addr=&(((HPUBYTE)sAlarmsBlockDefs[ct].hpvStart)[STORAGEGRANULARITY*ctp]);
            stor_size=STORAGEGRANULARITY;

            blkcode=blkstor_enumvalid(&stor_addr, &stor_size, &blk_addr);

                // just first must be the right one
            if(blkcode==DATACODE_SYSLOG_ALARMS)
            {
                if(blkstor_getdata(blk_addr,0,DATACODE_SYSLOG_ALARMS,&alrmlog,sizeof(alrmlog))>0)
                {
                    for(cti=0;cti<SYSLOGDATA_ALARMS_MAX_ENTRIES;cti++)
                    {
                            // if found NULL, then either is first entry or is the oldest
                            // entry yet found
                        if(elst[cti].hpvAddress==NULL)
                        {
                            elst[cti].ulAbsTime=alrmlog.ulAbsoluteTime;
                            elst[cti].hpvAddress=found_addr;
                            elst[cti].uwSize=(UWORD)(stor_size+(UWORD)((ULONG)stor_addr-(ULONG)blk_addr));
                            break;
                        }
                        
                            // if found an older entry than the actual one, then
                            // move oldest entries
                        if(elst[cti].ulAbsTime<alrmlog.ulAbsoluteTime)
                        {
                            for(cts=SYSLOGDATA_ALARMS_MAX_ENTRIES-1;cts>cti;cts--)
                                elst[cts]=elst[cts-1];
    
                            elst[cti].ulAbsTime=alrmlog.ulAbsoluteTime;
                            elst[cti].hpvAddress=blk_addr;
                            elst[cti].uwSize=(UWORD)(stor_size+(UWORD)((ULONG)stor_addr-(ULONG)blk_addr));
                            break;
                        }
    
                            // if found an entry with same abstime then overwrite it
                        if(elst[cti].ulAbsTime==alrmlog.ulAbsoluteTime)
                        {
                            elst[cti].ulAbsTime=alrmlog.ulAbsoluteTime;
                            elst[cti].hpvAddress=blk_addr;
                            elst[cti].uwSize=(UWORD)(stor_size+((ULONG)stor_addr-(ULONG)blk_addr));
                            break;
                        }
                    }
                    
                    if(alrmlog.ulAbsoluteTime>alarmabstime)
                    {
                        alarmabstime=alrmlog.ulAbsoluteTime;
                        hpvAlarmNextFree=found_addr;
                    }
                }
            }
        }
    }

        // set next free for the first time if NULL
    if(hpvAlarmNextFree==NULL)
        hpvAlarmNextFree=sAlarmsBlockDefs[0].hpvStart;

        // set the newest page
    if(!setnextfree(sAlarmsBlockDefs, ALARMSBLOCKCOUNT, &hpvAlarmNextFree))
        bFlashStorageEnabled=FALSE;
                
        // now fill-up the alarm data collection ram table
        // scan table from oldest to newer
    for(cti=SYSLOGDATA_ALARMS_MAX_ENTRIES-1;cti>=0;cti--)
        if(elst[cti].hpvAddress)
        {
            assert(blkstor_getdata(elst[cti].hpvAddress,0,DATACODE_SYSLOG_ALARMS,&alrmlog,sizeof(alrmlog))>0);

            assert(SysLogData_InsertIntoAlarmHistory(&alrmlog, &((HPUBYTE)(elst[cti].hpvAddress))[sizeof(alrmlog)], \
                elst[cti].uwSize-sizeof(alrmlog)));
        }

        // last set-up total power on time taking the maximum value between clock, alarm logs
        // and parameter saving
    if(alarmabstime>abstime)
        abstime=alarmabstime;
    if(sParMgmParamSignature.ulTimeStamp>abstime)
        abstime=sParMgmParamSignature.ulTimeStamp;

        // add one second to the last valid one in order to restart with power on time
        // greater than last saved one
    abstime++;

        // set power on time
    atomic_write((HPULONG)&ulSysTimersTotalPowerOnTime, &abstime, sizeof(ulSysTimersTotalPowerOnTime));

        // add task for log storage management
    assert(TaskSched_AddBackgroundTask(&slowtask));

        // save last occurred alarm time and last saved clock
    ulAlarmLastTime=alarmabstime;
    ulClockLastTime=ulClockLastSavedTime=abstime;

        // if not enable then post alarm
    if(!bFlashStorageEnabled)
        SysLogMgm_PostAlarm(SYSTEMALARMS_BIT_HW_FLASH_FAIL, SYSTEMALARMS_SUBCODE_HF_FLASH_SYSLOG, FALSE);

        // and enable syslog manager
    bSysLogManagerEnabled=1;

    return TRUE;
}

//***************************************************************************
// Prepare next location to store data

static BOOL setnextfree(const BLOCKDEFS * blkdefs, const UWORD blkcount, void  * * blkpointer)
{
    UWORD blkidx;
    ULONG blkptr;

        // if flash storage disabled then exit as flash failure
    if(!bFlashStorageEnabled)
        return TRUE;

        // actual pointer
    blkptr=(ULONG)*blkpointer;

        // find the block in which lie the actual pointer
    for(blkidx=0;blkidx<blkcount;blkidx++)
        if(blkptr>=(ULONG)blkdefs[blkidx].hpvStart && blkptr<((ULONG)blkdefs[blkidx].hpvStart+blkdefs[blkidx].ulSize))
            break;

    assert(blkidx<blkcount);

    for(;;)
    {
            // try next
        blkptr+=STORAGEGRANULARITY;

            // if out of this block
        if(blkptr>=((ULONG)blkdefs[blkidx].hpvStart+blkdefs[blkidx].ulSize))
        {
                // select next block
            blkidx++;
            if(blkidx>=blkcount)
                blkidx=0;

                // then erase it
           if(ProgramFlashErase(blkdefs[blkidx].hpvStart, blkdefs[blkidx].ulSize))
               return FALSE;

                // and location is at beginning of this block
            *blkpointer=blkdefs[blkidx].hpvStart;
            return TRUE;
        }

            // check location is erased
       if(ProgramFlashErasedCheck((HPVOID)blkptr, STORAGEGRANULARITY)==0)
       {
               // if yes location is found
           *blkpointer=(HPVOID)blkptr;
           return TRUE;
       }
    }
}

//***************************************************************************
// Power fail storage

void SysLogMgm_PowerOnFail(void)
{
    POWERFAILSAVE  * pfailsave;
    HPUBYTE hpubWriteBuf;

        // select alarm or clock, alarm has high priority
    if(psAlarmPowerFailSave)
        pfailsave=psAlarmPowerFailSave;
    else
    {
        pfailsave=psClockPowerFailSave;
            // check area by CRC for data consistency, only for
            // clock as for alarm time is critical
        if(pfailsave)
            if(pfailsave->uwCrc!=crc16(CRCINITIALSEED, pfailsave->hpvSrc, STORAGEGRANULARITY))
                pfailsave=NULL;
    }

        // if not booting and valid pointer
    if(!bSysStatBooting && pfailsave)
    {
            // disable write protection
        SecurityFlashDisableWriteProtection( 0x55AA, 0xAA55 );

            // disable OS exclusive flash lock
        bProgramFlashCritSectBypass=TRUE;

            // encode data
        hpubWriteBuf=encodelogchunk(pfailsave->hpvSrc,NULL);

            // write pre-prepared block
        ProgramFlashLoadWritePage((unsigned long)(pfailsave->hpvDst), (unsigned char *)hpubWriteBuf, STORAGEGRANULARITY);
    }

        // then execute a reset in case of power good
#ifdef _APP_DEBUG
    SysRes_ExecuteReset(RESETCODE_CLEANREBOOTREQUESTED, ~RESETCODE_CLEANREBOOTREQUESTED);
#else
    SysRes_ExecuteReset(SYSRES_POWERON_VALUE_PAR0, SYSRES_POWERON_VALUE_PAR1);
#endif
}

//***************************************************************************
// Post new alarm; is taken in account that this function could be called
// from everywhere (e.g. slow tasks, events, realtime, interrupts)
// in case called from realtime task or interrupts with ILVL greater than
// realtime task, it use one of the two pre-allocated area buffer for
// storage in order to minimize time, otherwise rely on standard queue method 

void SysLogMgm_PostAlarm(ULONG ulAlarmMask, ULONG ulAlarmSubCode, SBYTE bStore)
{
    HPUBYTE hpubBuf=psAlarmQueue;
    HPUBYTE hpubBPtr;
    ULONG sysalarms;
    SWORD leftsize;
    SYSLOGMGM_DATATMPIDENT  * psIdent;
    SYSLOGMGM_ALARMLOG  * psAlarmLog;
//    ULONG ulAlarmElementCnt;

        // if fall in the disabled alarms category then exit immediately
    if(ulAlarmMask&ulDisabledAlarmMask)
        return;

        // set and get system alarm mask
    sysalarms=atomic_long_set_bits(&ulSystemAlarms,ulAlarmMask);

        // if this alarm has more priority than the other ones
        // then setup also subcode, otherwise leave it to the
        // most priority one
    if((sysalarms&(ulAlarmMask-1))==0ul)
        atomic_write(&ulSystemAlarmSubCode,&ulAlarmSubCode,sizeof(ulSystemAlarmSubCode));
    
        // update system status flag
    bSysStatFault=(ulSystemAlarms!=0l); 

        // if log manager enabled
    if(bSysLogManagerEnabled)
    {
            // if it's to be stored try to use the fast buffers
        if(bStore)
        {
            UBYTE  * nubFastBuf;

            nubFastBuf=NULL;
//            if(_testset_(bRTPostAlarmValid0))
//                nubFastBuf=nubRTPostAlarmArea0;
//            else if(_testset_(bRTPostAlarmValid1))
//                nubFastBuf=nubRTPostAlarmArea1;
            
            if(nubFastBuf)
            {
                register UBYTE  * nubFastBPtr=nubFastBuf;
                register void  * pvAlarmLog;
                void  * pvIdent;

                    // begin with alarm log, allocate space
                pvIdent=(void  *)nubFastBPtr;
                nubFastBPtr=&nubFastBPtr[sizeof(BLKSTOR_HEADER)];
        
                pvAlarmLog=(void  *)nubFastBPtr;
                nubFastBPtr=&nubFastBPtr[sizeof(SYSLOGMGM_ALARMLOG)];
        
                    // then fill up data
                ((SYSLOGMGM_DATATMPIDENT *)pvIdent)->swCode=DATACODE_SYSLOG_ALARMS;
                ((SYSLOGMGM_DATATMPIDENT *)pvIdent)->uwSize=sizeof(SYSLOGMGM_ALARMLOG);

                    // critical section for powerontime selection
                DISABLE_IRQ();
                if(ulAlarmLastTime<ulSysTimersTotalPowerOnTime)
                    ulAlarmLastTime=ulSysTimersTotalPowerOnTime;
                else
                    ulAlarmLastTime++;
                ((SYSLOGMGM_ALARMLOG *)pvAlarmLog)->ulAbsoluteTime=ulAlarmLastTime;
                RESTORE_IRQ();

                ((SYSLOGMGM_ALARMLOG *)pvAlarmLog)->ulActiveAlarms=sysalarms;
                ((SYSLOGMGM_ALARMLOG *)pvAlarmLog)->ulAlarm=ulAlarmMask;
                ((SYSLOGMGM_ALARMLOG *)pvAlarmLog)->ulAlarmSubCode=ulAlarmSubCode;

                    // now add system status data
                leftsize=SysLogData_PostAlarmData(nubFastBPtr, STORAGEGRANULARITY-sizeof(BLKSTOR_HEADER)-sizeof(SYSLOGMGM_ALARMLOG), ulAlarmMask);

                    // integrity check
                assert(leftsize>=sizeof(SYSLOGMGM_DATATMPIDENT));

                    // then write termination at the end
                pvIdent=((void  *)(&nubFastBuf[STORAGEGRANULARITY-leftsize]));
                ((SYSLOGMGM_DATATMPIDENT *)pvIdent)->swCode=DATACODE_SYSLOG_INVALID;
                ((SYSLOGMGM_DATATMPIDENT *)pvIdent)->uwSize=POSTOPTIONS_NONE;

                    // critical section for updating pointer pairs for power fail
                DISABLE_IRQ();
                if(psAlarmPowerFailSave==NULL)
                {
                        // if was NULL then immediately set with this new alarm
                    uwAlarmPowerFailSaveSel=(uwAlarmPowerFailSaveSel>=POWERFAILSAVEELEMENTS-1 ? uwAlarmPowerFailSaveSel+1 : 0);
                    sAlarmPowerFailSave[uwAlarmPowerFailSaveSel].hpvSrc=nubFastBuf;
                    sAlarmPowerFailSave[uwAlarmPowerFailSaveSel].hpvDst=hpvAlarmNextFree;

                        // update here as power fail trap is NMI and can also break atomic sequences
                    psAlarmPowerFailSave=&sAlarmPowerFailSave[uwAlarmPowerFailSaveSel];
                }
                RESTORE_IRQ();

                return;
            }
        }

            // get an empty element to fill (if ILVL less than realtime ILVL or
            // fast area are yet full), if not found bypass storage
//        if(Os_QueueGet(SysLogMgm_AlrmAvailableElements,&ulAlarmElementCnt,0))
        {
            hpubBPtr=hpubBuf;

                // begin with alarm log, allocate space
            psIdent=(SYSLOGMGM_DATATMPIDENT  *)hpubBPtr;
            hpubBPtr=&hpubBPtr[sizeof(BLKSTOR_HEADER)];

            psAlarmLog=(SYSLOGMGM_ALARMLOG  *)hpubBPtr;
            hpubBPtr=&hpubBPtr[sizeof(SYSLOGMGM_ALARMLOG)];

                // then fill up data
            psIdent->swCode=DATACODE_SYSLOG_ALARMS;
            psIdent->uwSize=sizeof(SYSLOGMGM_ALARMLOG);

                // critical section for powerontime selection
            DISABLE_IRQ();
            if(ulAlarmLastTime<ulSysTimersTotalPowerOnTime)
                ulAlarmLastTime=ulSysTimersTotalPowerOnTime;
            else
                ulAlarmLastTime++;
            psAlarmLog->ulAbsoluteTime=ulAlarmLastTime;
            RESTORE_IRQ();

            psAlarmLog->ulActiveAlarms=sysalarms;
            psAlarmLog->ulAlarm=ulAlarmMask;
            psAlarmLog->ulAlarmSubCode=ulAlarmSubCode;

                // now add system status data
            leftsize=SysLogData_PostAlarmData(hpubBPtr, STORAGEGRANULARITY-sizeof(BLKSTOR_HEADER)-sizeof(SYSLOGMGM_ALARMLOG), ulAlarmMask);

                // integrity check
            assert(leftsize>=sizeof(SYSLOGMGM_DATATMPIDENT));

                // then write termination at the end
            psIdent=(SYSLOGMGM_DATATMPIDENT  *)&hpubBuf[STORAGEGRANULARITY-leftsize];
            psIdent->swCode=DATACODE_SYSLOG_INVALID;
            if(bStore)
                psIdent->uwSize=POSTOPTIONS_NONE;
            else
                psIdent->uwSize=POSTOPTIONS_NOFLASHSTORE;

                // critical section for updating pointer pairs for power fail, just
                // if flash storage is requested
            if(bStore)
            {
                DISABLE_IRQ();
                if(psAlarmPowerFailSave==NULL)
                {
                        // if was NULL then immediately set with this new alarm
                    uwAlarmPowerFailSaveSel=(uwAlarmPowerFailSaveSel>=POWERFAILSAVEELEMENTS-1 ? uwAlarmPowerFailSaveSel+1 : 0);
                    sAlarmPowerFailSave[uwAlarmPowerFailSaveSel].hpvSrc=hpubBuf;
                    sAlarmPowerFailSave[uwAlarmPowerFailSaveSel].hpvDst=hpvAlarmNextFree;

                        // update here as power fail trap is NMI and can also break atomic sequences
                    psAlarmPowerFailSave=&sAlarmPowerFailSave[uwAlarmPowerFailSaveSel];
                }
                RESTORE_IRQ();
            }

                // post alarm in the queue
            Os_QueuePost(SysLogMgm_AlarmQueue, (HPULONG)hpubBuf);
        }
    }
}

//***************************************************************************
// Clear alarms masks

void SysLogMgm_ClearAlarms(SBYTE bFlag)
{
    if(!bFlag)
        return;

    DISABLE_IRQ();
    ulSystemAlarmSubCode=0l;
    ulSystemAlarms&=SYSTEMALARMS_UNCLEARABLEALARMS;
    bSysStatFault=(ulSystemAlarms!=0l);
    RESTORE_IRQ();
}

//***************************************************************************
// Clear specific alarm mask

void SysLogMgm_ClearAlarmMask(ULONG ulAlarmMask)
{
        // remove unclearable alarms
    ulAlarmMask&=~SYSTEMALARMS_UNCLEARABLEALARMS;

    DISABLE_IRQ();
    ulSystemAlarms&=~ulAlarmMask;
    bSysStatFault=(ulSystemAlarms!=0l);
    RESTORE_IRQ();
}

//***************************************************************************
// Disable specific alarm mask from being sent and/or stored
// For security it works only in preboot/boot and with specific key access

void SysLogMgm_SetDisableAlarmMask(ULONG ulAlarmMask, UWORD uwKey)
{
    if(uwKey==SYSLOGMGM_DISALM_KEY && bSysStatBooting)
        ulDisabledAlarmMask=ulAlarmMask;
}

//***************************************************************************
// Slow task

static void slowtask(void)
{
    HPUBYTE hpubBuf;
    HPUBYTE hpubWriteBuf;
    HPVOID hpflashptr;
    SYSLOGMGM_ALARMLOG alrmlog;
    ULONG clockread;
    SYSLOGMGM_DATATMPIDENT  * psIdent;
    SYSLOGMGM_CLOCKLOG  * psClockLog;
    SWORD leftsize;
    POWERFAILSAVE  * psactualpsfail;
    BOOL bfastarea0=FALSE,bfastarea1=FALSE;
    UWORD uwPostOptions;
    UBYTE alarmqueue[STORAGEGRANULARITY];

        // get actual clock
    atomic_read(&clockread, (HPULONG)&ulSysTimersTotalPowerOnTime, sizeof(ulSysTimersTotalPowerOnTime));

        // check if new alarm has posted and not yet saved
    if(Os_QueueStatus(SysLogMgm_AlarmQueue)==OS_QUEUESTATUS_VALID
            || (bRTPostAlarmValid0 && !bSavedRTAlarm0) || (bRTPostAlarmValid1 && !bSavedRTAlarm1)
            )
    {
            // get element from one of the sources
        if(bRTPostAlarmValid0 && !bSavedRTAlarm0)
        {
            bfastarea0=TRUE;
            hpubBuf=nubRTPostAlarmArea0;
        }
        else if(bRTPostAlarmValid1 && !bSavedRTAlarm1)
        {
            bfastarea1=TRUE;
            hpubBuf=nubRTPostAlarmArea1;
        }
        else
        {
        	hpubBuf = alarmqueue;
            Os_QueueGet(SysLogMgm_AlarmQueue,(ULONG *)hpubBuf,0);
        }

            // encode data
        hpubWriteBuf=encodelogchunk(hpubBuf,&uwPostOptions);

            // check if save into flash is not requested (no history)
        if(uwPostOptions!=POSTOPTIONS_NOFLASHSTORE)
        {
                // save actual page pointer
            hpflashptr=hpvAlarmNextFree;

                // and prepare new one
            if(!setnextfree(sAlarmsBlockDefs, ALARMSBLOCKCOUNT, &hpvAlarmNextFree) && bFlashStorageEnabled)
            {
                bFlashStorageEnabled=FALSE;
                SysLogMgm_PostAlarm(SYSTEMALARMS_BIT_HW_FLASH_FAIL, SYSTEMALARMS_SUBCODE_HF_FLASH_SYSLOG, FALSE);
            }

                // no critical section here as, if here then there's at last one alarm in the queue,
                // then psAlarmPowerFailSave is not NULL as set by first SysLogMgm_PostAlarm call
                // subsequent SysLogMgm_PostAlarm see psAlarmPowerFailSave not NULL then do nothing
            uwAlarmPowerFailSaveSel=(uwAlarmPowerFailSaveSel>=POWERFAILSAVEELEMENTS-1 ? uwAlarmPowerFailSaveSel+1 : 0);

                // prepare for saving same element but at next location, in case flash writing is
                // interrupted by power fail
            sAlarmPowerFailSave[uwAlarmPowerFailSaveSel].hpvSrc=hpubBuf;
            sAlarmPowerFailSave[uwAlarmPowerFailSaveSel].hpvDst=hpvAlarmNextFree;

                // update here as power fail trap is NMI and can break also atomic sequences
            psAlarmPowerFailSave=&sAlarmPowerFailSave[uwAlarmPowerFailSaveSel];

                // now can write flash
            if(bFlashStorageEnabled)
                if(ProgramFlashLoadWritePage((unsigned long)hpflashptr, (unsigned char *)hpubWriteBuf, STORAGEGRANULARITY))
                {
                    bFlashStorageEnabled=FALSE;
                    SysLogMgm_PostAlarm(SYSTEMALARMS_BIT_HW_FLASH_FAIL, SYSTEMALARMS_SUBCODE_HF_FLASH_SYSLOG, FALSE);
                }

                // now alarm entry is safely written in flash, leave psAlarmPowerFailSave untouched
                // in order to not change sequence of written alarms, in the worst case the first alarm
                // is safely saved, then itself or the following ones are written twice, this case is
                // detected by inititialization
        }

            // signal saved fast areas
        if(bfastarea0)
            bSavedRTAlarm0=TRUE;
        else if(bfastarea1)
            bSavedRTAlarm1=TRUE;
//        else
//            Os_QueuePost(SysLogMgm_AlrmAvailableElements, (ULONG)&hpubBuf);

            // add alarm to history table
        assert(blkstor_getdata(hpubWriteBuf,0,DATACODE_SYSLOG_ALARMS,&alrmlog,sizeof(alrmlog))>0);
        assert(SysLogData_InsertIntoAlarmHistory(&alrmlog, &hpubWriteBuf[sizeof(alrmlog)], STORAGEGRANULARITY-sizeof(alrmlog)));

            // update save clock checkpoint as alarm has clock that is also used at startup
        ulClockLastSavedTime=clockread;
    }
    else
    {
            // if here no alarms in the queue
        psAlarmPowerFailSave=NULL;

            // release fast areas
        if(bSavedRTAlarm0)
            bSavedRTAlarm0=bRTPostAlarmValid0=FALSE;
        if(bSavedRTAlarm1)
            bSavedRTAlarm1=bRTPostAlarmValid1=FALSE;

            // if more than previous prepare new data for power fail
        if(clockread>ulClockLastTime)
        {
                // get next location for safe data collection
            uwClockPowerFailSaveSel=uwClockPowerFailSaveSel>=POWERFAILSAVEELEMENTS-1 ? 0 : uwClockPowerFailSaveSel+1;
            hpubWriteBuf=(HPUBYTE)&psClockSave[uwClockPowerFailSaveSel];
            leftsize=STORAGEGRANULARITY;

                // begin with clock log, allocate space
            psIdent=(SYSLOGMGM_DATATMPIDENT  *)hpubWriteBuf;
            leftsize-=sizeof(BLKSTOR_HEADER);

            psClockLog=(SYSLOGMGM_CLOCKLOG  *)&hpubWriteBuf[STORAGEGRANULARITY-leftsize];
            leftsize-=sizeof(SYSLOGMGM_CLOCKLOG);

                // then fill up data
            psIdent->swCode=DATACODE_SYSLOG_CLOCK;
            psIdent->uwSize=sizeof(SYSLOGMGM_CLOCKLOG);

            psClockLog->ulAbsoluteTime=clockread;

                // now add system status data
            leftsize=SysLogData_PostClockData(&hpubWriteBuf[STORAGEGRANULARITY-leftsize], leftsize);

                // and plc retain data
            leftsize=PlcRetMgr_PostClockData(&hpubWriteBuf[STORAGEGRANULARITY-leftsize], leftsize);

                // integrity check
            assert(leftsize>=sizeof(SYSLOGMGM_DATATMPIDENT));

                // then write termination at the end
            psIdent=(SYSLOGMGM_DATATMPIDENT  *)&hpubWriteBuf[STORAGEGRANULARITY-leftsize];
            psIdent->swCode=DATACODE_SYSLOG_INVALID;

                // now update pointer pairs for power fail
            sClockPowerFailSave[uwClockPowerFailSaveSel].hpvSrc=hpubWriteBuf;
            sClockPowerFailSave[uwClockPowerFailSaveSel].hpvDst=hpvClockNextFree;

                // update crc of the block in order that if reset is generated by external button
                // and/or software reset this could recover system timer; this is used also by
                // power fail trap to double check data consistency
            puwClockElemCrc[uwClockPowerFailSaveSel]=crc16(CRCINITIALSEED, hpubWriteBuf, STORAGEGRANULARITY);
            sClockPowerFailSave[uwClockPowerFailSaveSel].uwCrc=puwClockElemCrc[uwClockPowerFailSaveSel];

                // update here as power fail trap is NMI and can also break atomic sequences
            psClockPowerFailSave=&sClockPowerFailSave[uwClockPowerFailSaveSel];

                // update clock checkpoint
            ulClockLastTime=clockread;
        }

            // if last time since clock has written to flash (taking in account also alarms)
            // is more than SAVECLOCKEVERYNSECONDS or syslog flush has requested
            // then force write
        if(clockread-ulClockLastSavedTime > SAVECLOCKEVERYNSECONDS || bSysStatSysLogFlush)
        {
                // get next location for safe data collection
            uwClockPowerFailSaveSel=uwClockPowerFailSaveSel>=POWERFAILSAVEELEMENTS-1 ? 0 : uwClockPowerFailSaveSel+1;
            hpubBuf=(HPUBYTE)&psClockSave[uwClockPowerFailSaveSel];

                // then copy actual one
            memcpy(hpubBuf, psClockPowerFailSave->hpvSrc, STORAGEGRANULARITY);

                // and prepare new one
            if(!setnextfree(sClockBlockDefs, CLOCKBLOCKCOUNT, &hpvClockNextFree) && bFlashStorageEnabled)
            {
                bFlashStorageEnabled=FALSE;
                SysLogMgm_PostAlarm(SYSTEMALARMS_BIT_HW_FLASH_FAIL, SYSTEMALARMS_SUBCODE_HF_FLASH_SYSLOG, FALSE);
            }

                // now update pointer pairs for power fail
            sClockPowerFailSave[uwClockPowerFailSaveSel].hpvSrc=hpubBuf;
            sClockPowerFailSave[uwClockPowerFailSaveSel].hpvDst=hpvClockNextFree;

                // update crc of the block in order that if reset is generated by external button
                // and/or software reset this could recover system timer; this is used also by
                // power fail trap to double check data consistency
            puwClockElemCrc[uwClockPowerFailSaveSel]=crc16(CRCINITIALSEED, hpubBuf, STORAGEGRANULARITY);
            sClockPowerFailSave[uwClockPowerFailSaveSel].uwCrc=puwClockElemCrc[uwClockPowerFailSaveSel];

                // keep actual one
            psactualpsfail=psClockPowerFailSave;

                // update here as power fail trap is NMI and can also break atomic sequences
            psClockPowerFailSave=&sClockPowerFailSave[uwClockPowerFailSaveSel];

                // now encode data
            hpubWriteBuf=encodelogchunk(psactualpsfail->hpvSrc,NULL);

                // now can write flash
            if(bFlashStorageEnabled)
                if(ProgramFlashLoadWritePage((unsigned long)psactualpsfail->hpvDst, (unsigned char *)hpubWriteBuf, STORAGEGRANULARITY))
                {
                    bFlashStorageEnabled=FALSE;
                    SysLogMgm_PostAlarm(SYSTEMALARMS_BIT_HW_FLASH_FAIL, SYSTEMALARMS_SUBCODE_HF_FLASH_SYSLOG, FALSE);
                }

                // update clock checkpoint
            ulClockLastSavedTime=clockread;

                // if here alarm queue and clock are safely written in flash
            bSysStatSysLogFlush=FALSE;
        }
    }
}

//***************************************************************************
// Take one posted log element, then encode it with blockstorage in order
// to write it into flash; it allocate and return a static buffer, as
// system guaranteed no more than one buffer per time is written into flash

static HPUBYTE encodelogchunk(HPUBYTE hpubBuf, UWORD * puwPostOptions)
{
    static UBYTE  destbuf[STORAGEGRANULARITY];
    SYSLOGMGM_DATATMPIDENT  * psIdent;
    HPUBYTE bufptr=destbuf;

    while(((SYSLOGMGM_DATATMPIDENT  *)hpubBuf)->swCode != DATACODE_SYSLOG_INVALID)
    {
        psIdent=(SYSLOGMGM_DATATMPIDENT  *)hpubBuf;

            // fillup header info
        assert(blkstor_createheader(psIdent->swCode, &hpubBuf[sizeof(BLKSTOR_HEADER)], psIdent->uwSize, (BLKSTOR_HEADER  *)bufptr)>=0);

            // copy data            
        memcpy(&bufptr[sizeof(BLKSTOR_HEADER)], &hpubBuf[sizeof(BLKSTOR_HEADER)], psIdent->uwSize);

            // update pointers
        hpubBuf=&hpubBuf[sizeof(BLKSTOR_HEADER)+psIdent->uwSize];
        bufptr=&bufptr[sizeof(BLKSTOR_HEADER)+psIdent->uwSize];
    }

        // pass post options back if needed
    if(puwPostOptions)
        *puwPostOptions=((SYSLOGMGM_DATATMPIDENT  *)hpubBuf)->uwSize;

    return destbuf;
}
